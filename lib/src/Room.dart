/*
 * Copyright (c) 2019 Zender & Kurtz GbR.
 *
 * Authors:
 *   Christian Pauly <krille@famedly.com>
 *   Marcel Radzio <mtrnord@famedly.com>
 *
 * This file is part of famedlysdk.
 *
 * famedlysdk is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * famedlysdk is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with famedlysdk.  If not, see <http://www.gnu.org/licenses/>.
 */

import 'package:famedlysdk/src/Client.dart';
import 'package:famedlysdk/src/Event.dart';
import 'package:famedlysdk/src/responses/ErrorResponse.dart';
import 'package:famedlysdk/src/sync/EventUpdate.dart';
import 'package:famedlysdk/src/utils/ChatTime.dart';
import 'package:famedlysdk/src/utils/MxContent.dart';

import './User.dart';
import 'Connection.dart';
import 'Timeline.dart';

/// Represents a Matrix room.
class Room {
  /// The full qualified Matrix ID for the room in the format '!localid:server.abc'.
  final String id;

  /// Membership status of the user for this room.
  Membership membership;

  /// The name of the room if set by a participant.
  String name;

  /// Whether this room has a name or the name is generated by member names.
  bool hasName = false;

  /// The topic of the room if set by a participant.
  String topic;

  /// The avatar of the room if set by a participant.
  MxContent avatar = MxContent("");

  /// The count of unread notifications.
  int notificationCount;

  /// The count of highlighted notifications.
  int highlightCount;

  String prev_batch;

  String draft;

  /// Time when the user has last read the chat.
  ChatTime unread;

  /// ID of the fully read marker event.
  String fullyRead;

  /// The address in the format: #roomname:homeserver.org.
  String canonicalAlias;

  /// If this room is a direct chat, this is the matrix ID of the user
  String directChatMatrixID;

  /// Must be one of [all, mention]
  String notificationSettings;

  /// Are guest users allowed?
  String guestAccess;

  /// Who can see the history of this room?
  String historyVisibility;

  /// Who is allowed to join this room?
  String joinRules;

  /// The needed power levels for all actions.
  Map<String, int> powerLevels = {};

  Event lastEvent;

  /// Your current client instance.
  final Client client;

  @Deprecated("Rooms.roomID is deprecated! Use Rooms.id instead!")
  String get roomID => this.id;

  @Deprecated("Rooms.matrix is deprecated! Use Rooms.client instead!")
  Client get matrix => this.client;

  @Deprecated("Rooms.status is deprecated! Use Rooms.membership instead!")
  String get status => this.membership.toString().split('.').last;

  Room({
    this.id,
    this.membership,
    this.name,
    this.hasName = false,
    this.topic,
    this.avatar,
    this.notificationCount,
    this.highlightCount,
    this.prev_batch = "",
    this.draft,
    this.unread,
    this.fullyRead,
    this.canonicalAlias,
    this.directChatMatrixID,
    this.notificationSettings,
    this.guestAccess,
    this.historyVisibility,
    this.joinRules,
    this.powerLevels,
    this.lastEvent,
    this.client,
  });

  /// The last message sent to this room.
  String get lastMessage {
    if (lastEvent != null)
      return lastEvent.getBody();
    else
      return "";
  }

  /// When the last message received.
  ChatTime get timeCreated {
    if (lastEvent != null)
      return lastEvent.time;
    else
      return ChatTime.now();
  }

  /// Call the Matrix API to change the name of this room.
  Future<dynamic> setName(String newName) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.PUT,
        action: "/client/r0/rooms/${id}/state/m.room.name",
        data: {"name": newName});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to change the topic of this room.
  Future<dynamic> setDescription(String newName) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.PUT,
        action: "/client/r0/rooms/${id}/state/m.room.topic",
        data: {"topic": newName});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to send a simple text message.
  Future<dynamic> sendText(String message, {String txid = null}) async {
    if (txid == null) txid = "txid${DateTime.now().millisecondsSinceEpoch}";
    final dynamic res = await client.connection.jsonRequest(
        type: HTTPType.PUT,
        action: "/client/r0/rooms/${id}/send/m.room.message/$txid",
        data: {"msgtype": "m.text", "body": message});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  Future<String> sendTextEvent(String message, {String txid = null}) async {
    final String type = "m.room.message";

    // Create new transaction id
    String messageID;
    final int now = DateTime.now().millisecondsSinceEpoch;
    if (txid == null) {
      messageID = "msg$now";
    } else
      messageID = txid;

    // Display a *sending* event and store it.
    EventUpdate eventUpdate =
        EventUpdate(type: "timeline", roomID: id, eventType: type, content: {
      "type": type,
      "event_id": messageID,
      "sender": client.userID,
      "status": 0,
      "origin_server_ts": now,
      "content": {
        "msgtype": "m.text",
        "body": message,
      }
    });
    client.connection.onEvent.add(eventUpdate);
    await client.store?.transaction(() {
      client.store.storeEventUpdate(eventUpdate);
      return;
    });

    // Send the text and on success, store and display a *sent* event.
    final dynamic res = await sendText(message, txid: messageID);

    if (res is ErrorResponse || !(res["event_id"] is String)) {
      // On error, set status to -1
      eventUpdate.content["status"] = -1;
      eventUpdate.content["unsigned"] = {"transaction_id": messageID};
      client.connection.onEvent.add(eventUpdate);
      await client.store?.transaction(() {
        client.store.storeEventUpdate(eventUpdate);
        return;
      });
    } else {
      eventUpdate.content["status"] = 1;
      eventUpdate.content["unsigned"] = {"transaction_id": messageID};
      eventUpdate.content["event_id"] = res["event_id"];
      client.connection.onEvent.add(eventUpdate);
      await client.store?.transaction(() {
        client.store.storeEventUpdate(eventUpdate);
        return;
      });
      return res["event_id"];
    }
    return null;
  }

  /// Call the Matrix API to leave this room.
  Future<dynamic> leave() async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST, action: "/client/r0/rooms/${id}/leave");
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to forget this room if you already left it.
  Future<dynamic> forget() async {
    client.store.forgetRoom(id);
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST, action: "/client/r0/rooms/${id}/forget");
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to kick a user from this room.
  Future<dynamic> kick(String userID) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST,
        action: "/client/r0/rooms/${id}/kick",
        data: {"user_id": userID});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to ban a user from this room.
  Future<dynamic> ban(String userID) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST,
        action: "/client/r0/rooms/${id}/ban",
        data: {"user_id": userID});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to unban a banned user from this room.
  Future<dynamic> unban(String userID) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST,
        action: "/client/r0/rooms/${id}/unban",
        data: {"user_id": userID});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to unban a banned user from this room.
  Future<dynamic> setPower(String userID, int power) async {
    Map<String, int> powerMap = await client.store.getPowerLevels(id);
    powerMap[userID] = power;

    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.PUT,
        action: "/client/r0/rooms/$id/state/m.room.power_levels",
        data: {"users": powerMap});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Call the Matrix API to invite a user to this room.
  Future<dynamic> invite(String userID) async {
    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.POST,
        action: "/client/r0/rooms/${id}/invite",
        data: {"user_id": userID});
    if (res is ErrorResponse) client.connection.onError.add(res);
    return res;
  }

  /// Request more previous events from the server.
  Future<void> requestHistory({int historyCount = 100}) async {
    final dynamic resp = await client.connection.jsonRequest(
        type: HTTPType.GET,
        action:
            "/client/r0/rooms/$id/messages?from=${prev_batch}&dir=b&limit=$historyCount");

    if (resp is ErrorResponse) return;

    prev_batch = resp["end"];
    client.store?.storeRoomPrevBatch(this);

    if (!(resp["chunk"] is List<dynamic> &&
        resp["chunk"].length > 0 &&
        resp["end"] is String)) return;

    List<dynamic> history = resp["chunk"];
    client.store?.transaction(() {
      for (int i = 0; i < history.length; i++) {
        EventUpdate eventUpdate = EventUpdate(
          type: "history",
          roomID: id,
          eventType: history[i]["type"],
          content: history[i],
        );
        client.connection.onEvent.add(eventUpdate);
        client.store.storeEventUpdate(eventUpdate);
        client.store.txn.rawUpdate(
            "UPDATE Rooms SET prev_batch=? WHERE id=?", [resp["end"], id]);
      }
      return;
    });
    if (client.store == null) {
      for (int i = 0; i < history.length; i++) {
        EventUpdate eventUpdate = EventUpdate(
          type: "history",
          roomID: id,
          eventType: history[i]["type"],
          content: history[i],
        );
        client.connection.onEvent.add(eventUpdate);
      }
    }
  }

  /// Sets this room as a direct chat for this user.
  Future<dynamic> addToDirectChat(String userID) async {
    Map<String, List<String>> directChats =
        await client.store.getAccountDataDirectChats();
    if (directChats.containsKey(userID)) if (!directChats[userID].contains(id))
      directChats[userID].add(id);
    else
      return null; // Is already in direct chats
    else
      directChats[userID] = [id];

    final resp = await client.connection.jsonRequest(
        type: HTTPType.PUT,
        action: "/client/r0/user/${client.userID}/account_data/m.direct",
        data: directChats);
    return resp;
  }

  /// Sends *m.fully_read* and *m.read* for the given event ID.
  Future<dynamic> sendReadReceipt(String eventID) async {
    final dynamic resp = client.connection.jsonRequest(
        type: HTTPType.POST,
        action: "/client/r0/rooms/$id/read_markers",
        data: {
          "m.fully_read": eventID,
          "m.read": eventID,
        });
    return resp;
  }

  /// Returns a Room from a json String which comes normally from the store.
  static Future<Room> getRoomFromTableRow(
      Map<String, dynamic> row, Client matrix) async {
    bool newHasName = false;
    String name = row["topic"];
    if (name == "" && !row["canonical_alias"].isEmpty)
      name = row["canonical_alias"];
    else if (name == "")
      name = await matrix.store?.getChatNameFromMemberNames(row["id"]) ?? "";
    else
      newHasName = true;

    String avatarUrl = row["avatar_url"];
    if (avatarUrl == "")
      avatarUrl = await matrix.store?.getAvatarFromSingleChat(row["id"]) ?? "";

    return Room(
      id: row["id"],
      name: name,
      hasName: newHasName,
      membership: Membership.values
          .firstWhere((e) => e.toString() == 'Membership.' + row["membership"]),
      topic: row["description"],
      avatar: MxContent(avatarUrl),
      notificationCount: row["notification_count"],
      highlightCount: row["highlight_count"],
      unread: ChatTime(row["unread"]),
      fullyRead: row["fully_read"],
      notificationSettings: row["notification_settings"],
      directChatMatrixID: row["direct_chat_matrix_id"],
      draft: row["draft"],
      prev_batch: row["prev_batch"],
      guestAccess: row["guest_access"],
      historyVisibility: row["history_visibility"],
      joinRules: row["join_rules"],
      canonicalAlias: row["canonical_alias"],
      powerLevels: {
        "power_events_default": row["power_events_default"],
        "power_state_default": row["power_state_default"],
        "power_redact": row["power_redact"],
        "power_invite": row["power_invite"],
        "power_ban": row["power_ban"],
        "power_kick": row["power_kick"],
        "power_user_default": row["power_user_default"],
        "power_event_avatar": row["power_event_avatar"],
        "power_event_history_visibility": row["power_event_history_visibility"],
        "power_event_canonical_alias": row["power_event_canonical_alias"],
        "power_event_aliases": row["power_event_aliases"],
        "power_event_name": row["power_event_name"],
        "power_event_power_levels": row["power_event_power_levels"],
      },
      lastEvent: Event.fromJson(row, null),
      client: matrix,
    );
  }

  @Deprecated("Use client.store.getRoomById(String id) instead!")
  static Future<Room> getRoomById(String id, Client matrix) async {
    Room room = await matrix.store.getRoomById(id);
    return room;
  }

  /// Load a room from the store including all room events.
  static Future<Room> loadRoomEvents(String id, Client matrix) async {
    Room room = await matrix.store.getRoomById(id);
    await room.loadEvents();
    return room;
  }

  /// Creates a timeline from the store. Returns a [Timeline] object.
  Future<Timeline> getTimeline(
      {onTimelineUpdateCallback onUpdate,
      onTimelineInsertCallback onInsert}) async {
    List<Event> events = await loadEvents();
    return Timeline(
      room: this,
      events: events,
      onUpdate: onUpdate,
      onInsert: onInsert,
    );
  }

  /// Load all events for a given room from the store. This includes all
  /// senders of those events, who will be added to the participants list.
  Future<List<Event>> loadEvents() async {
    return await client.store.getEventList(this);
  }

  /// Load all participants for a given room from the store.
  Future<List<User>> loadParticipants() async {
    return await client.store.loadParticipants(this);
  }

  /// Request the full list of participants from the server. The local list
  /// from the store is not complete if the client uses lazy loading.
  Future<List<User>> requestParticipants() async {
    List<User> participants = [];

    dynamic res = await client.connection.jsonRequest(
        type: HTTPType.GET, action: "/client/r0/rooms/${id}/members");
    if (res is ErrorResponse || !(res["chunk"] is List<dynamic>))
      return participants;

    for (num i = 0; i < res["chunk"].length; i++) {
      User newUser = User(res["chunk"][i]["state_key"],
          displayName: res["chunk"][i]["content"]["displayname"] ?? "",
          membership: Membership.values.firstWhere((e) =>
              e.toString() ==
                  'Membership.' + res["chunk"][i]["content"]["membership"] ??
              ""),
          avatarUrl: MxContent(res["chunk"][i]["content"]["avatar_url"] ?? ""),
          room: this);
      if (newUser.membership != Membership.leave) participants.add(newUser);
    }

    return participants;
  }

  /// Searches for the event in the store. If it isn't found, try to request it
  /// from the server. Returns null if not found.
  Future<Event> getEventById(String eventID) async {
    if (client.store != null) {
      final Event storeEvent = await client.store.getEventById(eventID, this);
      if (storeEvent != null) return storeEvent;
    }
    final dynamic resp = await client.connection.jsonRequest(
        type: HTTPType.GET, action: "/client/r0/rooms/$id/event/$eventID");
    if (resp is ErrorResponse) return null;
    return Event.fromJson(resp, this);
  }
}
